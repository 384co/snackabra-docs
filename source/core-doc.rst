
.. _techdetails:

=================
Technical Details
=================

You should have read :ref:`the technical overview <overview>` before
this section. Here we will fill in some nitty-gritty details that
aren't covered elsewhere.


.. _rooms:

Rooms
-----

All communication is centered around a :term:`Room`.

The :term:`Room Name` is a 48-byte [#f011]_ URI [#f012]_ encoded in 64
characters of b64 [#f013]_. This name is globally unique [#f014]_, including
across servers.

An example would be:

::

   Raih2xfY6D8aKVIlkIeDLIbSpt0qNmU2mUTXYiJQoNSU-SgyTLC0FReui0OhX1Q8

We variously refer to this identifier as "<room>", “<roomId>”, “room
identifier”, or “room name”.

This URI is generated using (Python) ``secrets.token_urlsafe``
[#f010]_ in the :ref:`command line tools <command-line>`.
(UPDATE: this is changing to be derived from a generated owner public key.)

The location (server) where a room is created is called the
:term:`Origin Server`. Note that the identity of the origin server is
in no manner reflected in the name of a room. [#f015]_

The same <room> identifier is used on different servers: if you
have a staging environment for your front end code, for example,
but share backend databases.

The main MI service hosts rooms here:

::

   https//s.privacy.app/<room>

Or you can run a :term:`Personal Room Server` if you like.

.. _owner definition:

An :term:`Owner` is a verified user, authenticated in some manner;
for a public server typically through an :term:`SSO`

Our baseline use case is an MI Member
https://privacy.app where owners are authenticated with an MI
membership number, an assigned Yubico hardware security key, and PIN
code. However, the intent of this design is that it should be
stand-alone from any particulars of authentication, but it does assume
the presence of some such authentication.
For example, for a :term:`Personal Room Server`, it's a server secret
that the admin of the site has.

Room identifiers are unique, global, and persistent. [#f016]_ They are
transportable in a natural way: no matter how many people host a
service using this design, the probability of any new rooms from any
two services colliding is practically zero. Both our current web app and iOS clients
support export / import of conversations. See our discussion on
:ref:`micro-federation <micro-federation>`. 

The :ref:`command line tools <command-line>` include support
for generating "business cards" with QR codes for a room, the
idea being that you can share these with people you meet, instead
of :term:`PII` like emails or phone numbers.


Room and User Keys
------------------

The two basic key *types* are:

* Public keys:

  * RSA public-key pair, using SECG curve secp3841 (aka NIST P-384)
    This pair is generated by :func:`snackabra.crypto.gen_p384_pair`.
 
  * Python library: ``ec.generate_private_key(ec.SECP384R1())`` [#f021]_

  * NSS (Firefox) currently supports NIST curves P-256, P-384,
    P-521. However, apparently P-521 is not widely supported [#f017]_  as it is
    not part of "NIST Suite B". [#f018]_

  * ECDH is used to agree on a key [#f019]_
    between two parties [#f020]_. 

* Encryption keys:

  * AES 256-bit (A256GCM) symmetric key

  * Currently generated using jwk [#f022]_
    library (it’s just 256
    random bits). Generated by :func:`snackabra.crypto.gen_aes_key_jwk`. 

Key instances, the following are pre-generated and stored by the :term:`SSO`:

* <room>_ownerKey  - *[Public key pair]*

  * public room key, used to claim ownership of the room, and to verify anything signed by the Owner

  * *(existence of this does not imply that the Durable Object for the
    room has been created, but it means it will be created when
    accessed)*

  * private half of this is stored in Owner (SSO) data only

  * When owner joins room, private half stored in Owner’s
    local_storage as <room>_room

  * The public half of this key is also stored in the localstorage

  * Owner can secure key management by generating a new key pair and
    saving the public half as a new entry in the KV_global as
    <room>_ownerKey<ts>, where ts is the timestamp when they updated
    the key. The private half of this newly generated pair will be
    saved only in their localstorage. [#f023]_

* <room>_signKey - *[Public key pair]*

  * The private room signing key, used by visitors to sign back and
    forth (or more accurately, to derive a unique signing key).

  * All participants have access to this key (both halves).

* <room>_encryptionKey - *[Encryption key]*

  * The durable object keeps an encryption key, used for end to end
    encryption [#f024]_ unless the Owner has taken
    control of their key management

* <room>_authorizationKey - *[Public key pair]*

  * used to prove ownership of a room (SSO backend->Chat CF backend)

  * Only SSO backend has private key; SSO can verify it’s authority to
    the Chat CF backend by signing a cookie (or in future, have other
    admin APIs)

The following keys may eventually populate the room (KV_local):

* <room>_lockedKey - *[Public key pair]*

  * Generated if the owner "restricts" the room and stored in local
    storage of accepted guests

  * Used to send an end-to-end encrypted message in restricted rooms.

* <room>_guestKey

  * this is the public key of the *first* guest, used for purple
    outline on messages

  * (note: as always, visitor needs to keep track of their private
    half)

In addition to the above, every participant has in their
local_storage:

* <room> - *[Public key pair]*

  * This is the public/private pair used for all signing and
    whispering of messages

  * In the case of this being the Owner, it will match the
    <room>_ownerKey (public half) in the DO/KV_local

  * In the case of this being the Verified Guest (first visitor), it
    similarly matches the <room>_guestKey

  * (We will refer to this key as the ‘<room>_participant’ key or
    ‘participant keys’ in this document)

In addition to all of the above, a ‘global’ ledgerKey (RSA keyPair) is
also generated.

* The public half is used to encrypt the storage token id by KV_local
  after approving a storage request.

* The private half is only available to offline systems to be used for
  garbage collection and storage revocation.

Message Structure
-----------------

This is the basic message structure before end-to-end encryption:

These components are present in every message:

* encrypted - flag indicating if the message is whispered

* contents - text part of the message (encrypted if whispered)

* image - thumbnail image (encrypted if whispered)

* imageMetaData - KV information for image (encrypted if whispered)

* sender_pubKey - public key of the sender

These components are present if the message is not whispered:

* sign - sign for contents (text part)

* image_sign - sign for thumbnail image

* imageMetaData_sign - sign for imageMetaData

These components are present if the message is whispered to a guest by
the owner:

* recipient - public key of the recipient

NOTE: The Message Structure section will be updated to account for
control messages once finalized.

|
|

----------------

.. rubric:: Footnotes

.. [#f010] https://docs.python.org/3/library/secrets.html#generating-tokens


.. [#f011] Current token length of 48 bytes (512 random bits) is a
	   sufficiently large keyspace (10^154).

.. [#f012] https://en.wikipedia.org/wiki/Uniform_Resource_Identifier

.. [#f013] https://datatracker.ietf.org/doc/html/rfc4648.html

.. [#f014] Let’s say we have 10 billion users, who each have one
	   billion unique rooms. Now let’s say somebody runs a ‘bot’
	   to guess room names. Let’s say each bot can guess one
	   billion rooms names per second (which the servers won’t
	   allow obviously) - and they could do that for year after
	   year for 15 billion years (the age of the Universe) - and
	   let’s say they had as many computers as there are atoms in
	   the Universe (10^85) to all do this in parallel. And each
	   computer can run one million ‘bots’ - then they would still
	   only have 0.0000000000000000000000000000000000000000001%
	   chance of guessing any room.

.. [#f015] There is no way to assert the origin. Anybody can claim
	   that they were first to generate the name.
	   
.. [#f016] They also, by design, do not include any information about
	   their point of origin (what server created it).
	  
.. [#f017] Chrome has dropped it
	   https://bugs.chromium.org/p/chromium/issues/detail?id=478225
	   and NSS (Firefox) may or may not drop it
	   https://bugzilla.mozilla.org/show_bug.cgi?id=1128792

.. [#f018] https://csrc.nist.gov/csrc/media/events/ispab-march-2006-meeting/documents/e_barker-march2006-ispab.pdf

.. [#f019] https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#ecdh

.. [#f020] RFC6090 https://datatracker.ietf.org/doc/html/rfc6090

.. [#f021] https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/?highlight=generate_private_key#cryptography.hazmat.primitives.asymmetric.ec.generate_private_key	   
	   
.. [#f022] https://jwcrypto.readthedocs.io/en/latest/#
           (The randomness of that might be a slight issue.)

.. [#f023] In a future extension, the Owner will be able to hand back
	   "ultimate ownership" to the SSO server by providing the
	   private key to the SSO, in which case the SSO is again
	   managing the keys for the Owner. The primary use case for
	   this is server migration - the design details of which are
	   under development.

.. [#f024] Please also see discussion :ref:`'what do we mean by
           end-to-end encryption' <end-to-end-encryption>`.

